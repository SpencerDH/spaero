% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysis.R
\name{get_dynamic_acf}
\alias{get_dynamic_acf}
\title{Get dynamic autocorrelation function.}
\usage{
get_dynamic_acf(x, center_trend = "grand_mean", center_kernel = "gaussian",
  center_bandwidth = NULL, acf_trend = "local_constant",
  acf_kernel = "uniform", acf_bandwidth = NULL, acf = "correlation",
  lag = 1, nmulti = 5)
}
\arguments{
\item{x}{A univariate or multivariate numeric time series object or
a numeric vector or matrix.}

\item{center_trend}{Character string giving method of calculating
the trend to subtract. Allowed values are '"grand_mean"',
'"ensemble_means"', '"local_constant"', and '"local_linear"'. Will
be partially matched.}

\item{center_kernel}{Character string giving the kernel for any
local detrending. Allowed values are '"gaussian"' and '"uniform"'.}

\item{center_bandwidth}{Bandwith of kernel for any local detrending
done. If not supplied, a bandwidth will be selected by
cross-validation of least squared error.}

\item{acf_trend}{Character string giving method of smoothed
acf. Allowed values are '"local_constant"', and
'"local_linear"'. Will be partially matched.}

\item{acf_kernel}{Character string giving the kernel for local
smoothing of acf. Allowed values are '"gaussian"' and '"uniform"'.}

\item{acf_bandwidth}{Bandwith of kernel for any local smoothing of
acf done. If not supplied, a bandwidth will be selected by
cross-validation of least squared error.}

\item{acf}{Character string giving the type of acf to be
returned. Allowed values are '"correlation"' (the default), and
'"covariance"'. Will be partially matched.}

\item{lag}{Integer lag at which to calculate the acf. This lag is in terms
of the index of \code{x} and does not account for the frequency of
\code{x} if \code{x} is a time series. It should be positive.}

\item{nmulti}{Integer giving the number of starting pionts in
search for bandwidths if any are selected by cross validation.}
}
\value{
A list with elements '"centered"' and '"acf"'. '"centered"'
is a list of the detrend time series and the bandwidth used in the
detrening. '"acf"' is a list of the smoothed estimate of the acf
and the bandwidth used. If no bandwidth were used they will be
NULL.
}
\description{
\code{get_dynamic_acf} estimates time-dependent autocorrelation function from ensemble time series.
}
\details{
Any missing values in 'x' will cause an error.

Bandwidths affect weights in local smoothers as follows. To get the
local estimate corresponding to index i, the distance to each other
index j is calculated as (i - j) / h, where h is the
bandwidth. Then that distance is plugged into the kernel function
to obtain a weight. The weights are normalized to sum to one for
each index.

The gaussian kernel is a second order kernel that corresponds to
the gaussian density function. The uniform kernel is an indicator
function of whether the distance is less than 1. Thus selecting a
uniform kernel with a bandwidth of 2 is equivalent to a sliding
window of length 3 that is centered on the focal
index.

'"local_constant"' smoothers are local means computed with the
kernel weights. '"local_linear"' smoothers are the fitted values of
local linear regressions with the kernel weights. The linear
smoothers avoid biases that the one-sided kernels at the ends of
the time series can create for the local constant smoothers.

Using a uniform kernel will cause a warning about ignoring the
kernel order that can safely be ignored.
}
\examples{

# A highly autocorrelated time series
x <- 1:10
get_dynamic_acf(x, acf_bandwidth=3)

# Plot log of acf
plot(log(get_dynamic_acf(x, acf_bandwidth=3)$acf$smooth))

# Check estimates with AR1 simulations with lag-1 core 0.1
w <- rnorm(1000)
xnext <- function(xlast, w) 0.1 * xlast + w
x <- Reduce(xnext, x=w, init=0, accumulate=TRUE)
acf(x, lag.max=1, plot=FALSE)
head(get_dynamic_acf(x, acf_bandwidth=length(x))$acf$smooth)

# Check detrending ability
x2 <- x + seq(1, 10, len=length(x))
ans <- get_dynamic_acf(x2, center_trend="local_linear",
                       center_bandwidth=length(x), acf_bandwidth=length(x))
head(ans$acf$smooth)

# The simple acf estimate is inflated by the trend
acf(x2, lag.max=1, plot=FALSE)

# Check ability to estimate time-dependent autocorrelation
xnext <- function(xlast, w) 0.8 * xlast + w
xhi <- Reduce(xnext, x=w, init=0, accumulate=TRUE)
acf(xhi, lag.max=1, plot=FALSE)
wt <- seq(0, 1, len=length(x))
xdynamic <- wt * xhi + (1 - wt) * x
get_dynamic_acf(xdynamic, acf_bandwidth=100)$acf$smooth
}
\seealso{
\code{\link{acf}} for regular autcorrelation estimation
}

